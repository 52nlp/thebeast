#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{aaai}
\newcommand{\lang}{\textsc{DFacto}}
\end_preamble
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

: Open Up to Scale Up
\end_layout

\begin_layout Abstract
While many probabilistic programming language focus on restricting expressivenes
s to achieve complexity guarantees, we argue that we should rather design
 
\emph on
open
\emph default
 languages that are designed to grow over time.
 In the languages we envision, new types of constructs, such as cardinality
 constraints, projectivity assumptions, acyclicity, are constantly added
 to a ever increasing set of declarative building blocks.
 This leads to 
\emph on
more concise
\emph default
 programs.
 More importantly, we argue that it can also lead to
\emph on
 more efficient
\emph default
 inference if we use 
\emph on
compositional
\emph default
 inference methods that can exploit building-block specific sub-routines.
 We present 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

, a open-ended language to describe complex factor graphs, and extend it
 with projective spanning tree constraint.
 This constraint is used in place of a first order representation in a dependenc
y parsing application, and leads to dramatic speed ups.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In recent years Probabilistic Programming languages have been adopted in
 several fields, and used for applications such as Natural Language Processing,
 Planning, Sensor Networks, to name only a few.
 One of most successful approaches is Markov Logic, a language that uses
 weighted first order logic to describe Markov Networks of repetitive structure.
 It is one of the most expressive languages as it can describe arbitrary
 Markov Networks.
 Its expressiveness comes at a price: we loose any complexity guaranteees
 that less expressive langauges tend to give.
 If the user designs the 
\begin_inset Quotes eld
\end_inset

wrong
\begin_inset Quotes erd
\end_inset

 model, inference and learning will be painfully slow.
 While often there can be an efficient 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 model for the same task, there are cleary times when this is not the case.
 One example is dependency parsing, where we are required to model relation
 structure that represents projective trees.
 Formulating this in Markov Logic leads to graphical models with very high
 treewidth, and hence high complexity.
\end_layout

\begin_layout Standard
In this work we argue that Markov Logic, in order to scale up, needs to
 
\emph on
open up
\emph default
.
 That is, we propose to generalize Markov Logic to not provide a fixed and
 small set of logical connectives and universal or existential quantification.
 Instead, it should allow users to add their own constructs, such as existing
 Markov Logic building blocks, but also cardinality, projectivity or acyclicity
 constraints.
 The main function of the language is then to provide the glue to assemble
 these constructs.
 At first sight, new building blocks may only be syntactic sugar.
 Markov Logic can, albeit less concise, already express such constraints.
 However, for inference routines that decompose according to the structure
 of our model, the subroutines for these building blocks can often be implemente
d efficiently.
 For example, Belief Propagation essentially requires each factor to marginalize
 itself.
 For a spanning tree constraint this can be achieved in cubic time.
 
\end_layout

\begin_layout Standard
In the following we will present 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout
Declarative Factor Graphs, Open.
\end_layout

\end_inset

 an attempt to provide the glue for open-ended probabilistic programming.
 We have used it to (a) implement Markov Logic, and (b) extend it with powerful
 building blocks such as a projective spanning tree constraint.
 We show empirically that this allows us to implement a dramatically more
 efficient dependency parser than in pure Markov Logic.
 
\end_layout

\begin_layout Section
Domains, Variables, Worlds
\end_layout

\begin_layout Standard
The glue that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 provides are abstract datatypes/interfaces for building blocks, as well
 as a set of initial constructs.
 We will describe them using classes and traits of Scala, a functional object-or
iented programming language.
 
\end_layout

\begin_layout Standard
A 
\family typewriter
Domain[T]
\family default
 contains (Scala) objects we want to talk about; implementations of Domain
 usually need to provide an iterator over their objects, as well as a 
\family typewriter
contains
\family default
 method to indicate Domain membership.
 Note that a Domain can be infinite, and also be used when no enumeration
 of its objects is possible.
 
\end_layout

\begin_layout Standard
The three core types of domains are 
\family typewriter
Values, Tuples, 
\family default
and 
\family typewriter
Functions
\family default
.
 The former simply represents a user-defined set of objects of type T; the
 latter a the set of all functions from a domain to a target.
 
\end_layout

\begin_layout LyX-Code
val Tokens = Values(0,1,2,3,4,5,...)
\end_layout

\begin_layout LyX-Code
Val Bools  = Values(false,true)
\end_layout

\begin_layout LyX-Code
val Parses = (Tokens x Labels) -> Bools 
\end_layout

\begin_layout Standard
Ultimately we want to reason about the objects of our domains, using generic
 knowledge independent of their actual identity.
 To do so we need placeholders that allow us to speak about objects in an
 abstract fashion.
 This is generally achieved by variables.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 a variable is represented by objects of the trait 
\family typewriter
Var[T]
\family default
.
 Each variable has a name and a domain that specifies which values the variable
 can possibly take on.
 Variables can be simple (referring to simple objects) or complex (refering
 to functions) :
\end_layout

\begin_layout LyX-Code
val root = Var(
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

, Tokens)
\end_layout

\begin_layout LyX-Code
val parse = Var(
\begin_inset Quotes eld
\end_inset

parse
\begin_inset Quotes erd
\end_inset

, Parses)
\end_layout

\begin_layout Standard
One can understand each variable as a question about the world we seek to
 model.
 In this sense each assignment to our variables refers to a possible state
 of the world.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 we hence refer to assignments using the 
\family typewriter
World
\family default
 trait.
 The core method a 
\family typewriter
World
\family default
 provides is 
\family typewriter
resolveVar
\family default
: it returns the object the variable is assigned to, or 
\family typewriter
None
\family default
 if no such object exists (for partial worlds).
 To construct worlds we can use 
\family typewriter
MutableWorld
\family default
 objects:
\end_layout

\begin_layout LyX-Code
val world = new MutableWorld
\end_layout

\begin_layout LyX-Code
world(root) = 0
\end_layout

\begin_layout LyX-Code
world(parse) = Map((0,2)->true,(0,4)->true)
\end_layout

\begin_layout LyX-Code
world.close(parse)
\end_layout

\begin_layout Section
Terms and Factors
\end_layout

\begin_layout Standard
Intuitively, a term is a symbolic expression that is, given a possible world,
 evaluated to a value.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 a term is an instance of a 
\family typewriter
Term
\family default
 trait that has to implement a 
\family typewriter
evaluate(world)
\family default
 that defines how the term maps worlds to values.
 It also needs to provide a list of 
\family typewriter
Var
\family default
 objects that it depends on.
 
\end_layout

\begin_layout Standard
The core built-in Term classes are
\end_layout

\begin_layout Enumerate

\family typewriter
Var
\family default
: evaluates to the value it is assigned to
\end_layout

\begin_layout Enumerate

\family typewriter
Constant()
\family default
: evaluates to the given constant
\end_layout

\begin_layout Enumerate

\family typewriter
FunApp(f,a)
\family default
: evaluates to the result of applying f.evaluate to a.evaluate
\end_layout

\begin_layout Enumerate

\family typewriter
Quantification(o,v,f)
\family default
: ...
\end_layout

\begin_layout Standard
It should be clear that the above terms can be used to create a wide array
 of composite terms.
 For example...
\end_layout

\begin_layout Standard
Terms are the core building blocks we use to construct probability distributions
 over possible worlds.
 In our framework, a probability distribution is nothing more than a term
 that evaluates to real values between 0 and 1 that sum up to 1 for all
 possible assignments of its contained variables.
 Once your term fulfills this contract, we can apply basic brute-force inference
 algorithms to calculate expectations and find most likely assignments.
\end_layout

\begin_layout Standard
Obviously any exhaustive inference scheme becomes intractable when the number
 of variables in a term is large.
 However, inference is generally more tractable if terms factor into a product
 of sub-terms.
 In this case we can apply methods such as Belief Propagation that avoid
 summing over all possible worlds.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 such terms are instances of the 
\family typewriter
Factorizable
\family default
 trait, and need to provide a 
\family typewriter
factorize
\family default
 method that returns all terms the term factors in.
 
\end_layout

\begin_layout Section
Compositional Inference
\end_layout

\begin_layout Standard
Belief Propagation lends itsell well to compositional inference.
 Both in the case of Sum-Product BP
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "smith08dependency"

\end_inset

 and Max-Product BP
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Duchi07usingcombinatorial"

\end_inset

 is has been shown how to rewrite the BP update equations so that calculating
 outgoing factor messages amounts to performing marginal inference for the
 given factor alone (plus some local factors on each variable).
 Here we present the case of Sum-Product BP, but note that Max-Product BP
 has a very similar formulation.
 
\end_layout

\begin_layout Standard
In its canocial form, BP requires us to marginalize a variable for a factor
 term multiplied with the incoming messages from all but the current variable
 node.
 However, this marginalization can be rewritten as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\#\#\label{eq:BP-CI}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 BP is therefore supported by a 
\end_layout

\begin_layout LyX-Code

\family typewriter
marginalize(incoming:Beliefs):Beliefs
\end_layout

\begin_layout Standard
method for real valued terms 
\family typewriter
Term[Double]
\family default
.
 This method performs the calculation in equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BP-CI"

\end_inset

, and 
\family typewriter
incoming
\family default
 provides local beliefs for each variable contained in the term.
 By default this method exhaustively goes through all variable states of
 the variables in the term and sums up probabilities (or scores) for each
 variable as defined by 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BP-CI"

\end_inset

.
 However, for simple terms (such as weighted CNF terms) or more complicated
 ones (like a spanning tree constraint), we can provide tailor-made inference
 and gain efficiencies.
 
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
