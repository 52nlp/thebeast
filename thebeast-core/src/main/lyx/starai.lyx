#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{aaai}
\newcommand{\lang}{\textsc{DFacto}}
\end_preamble
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Declarative Probabilistic Programming for Undirected Graphical Models: Open
 Up to Scale Up
\end_layout

\begin_layout Abstract
We argue that probabilistic programming, in order to scale up, needs to
 
\emph on
open up
\emph default
.
 That is, instead of focussing on minimal sets of generic building blocks
 such as universal quantification and logical connectives, languages should
 
\emph on
grow
\emph default
 to include specific building blocks for as many uses cases as necessary.
 On first sight this is not more than syntactic sugar to make models 
\emph on
more concise
\emph default
.
 However, we argue and show that it can also lead to
\emph on
 more efficient
\emph default
 inference if we use inference methods that can exploit building-block specific
 sub-routines.
 To this end we present 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

, a open-ended framework for Undirected Graphical Models.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Probabilistic Programming languages such as Markov Logic
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "richardson06markov"

\end_inset

 and ? are very expressive.
 Many statistical models of interest can be readily described using the
 generic building blocks of these languages.
 However, in many cases the generic inference routines of the language interpret
er will either be too slow, too inaccurate, or both.
 For example, it is possible (albeit slightly convoluted) to use Markov
 Logic for encoding probability distributions over the set of possible syntactic
 dependency trees of a sentence.
 Yet, generic inference in these models is very inefficient, in particular
 due to deterministic factors such as the spanning tree constraint that
 induce high tree-width and strong interactions between variables.
 
\end_layout

\begin_layout Standard
Here we argue that probabilistic programming, in order to scale up, needs
 to 
\emph on
open up
\emph default
.
 That is, instead of focussing on minimal sets of generic building blocks
 such as universal quantification and logical connectives, languages should
 
\emph on
grow
\emph default
 to eventually include specific building blocks for as many uses cases as
 necessary.
 For example, we should provide a spanning tree constraint as part of our
 language that can be used whenever we want to extract dependency trees,
 of model hierachical structures in general.
 
\end_layout

\begin_layout Standard
On first sight, this is not more than syntactic sugar.
 However, we argue and show that it can also lead to
\emph on
 more efficient
\emph default
 inference if we use inference methods that can exploit building-block specific
 sub-routines.
 For example, Belief Propagation essentially requires each factor to marginalize
 itself.
 For a spanning tree constraint this can be done very efficiently.
\end_layout

\begin_layout Standard
Clearly, we do not want to design a language with all constructs we could
 ever need in advance.
 Instead, we need to provide the glue for an ever-increasing set of language
 
\emph on
extensions
\emph default
.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To this end we present 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

, a open-ended framework for Undirected Graphical Models.
\end_layout

\begin_layout Plain Layout
In recent years Probabilistic Programming languages have been adopted in
 several fields, and used for applications such as Natural Language Processing,
 Planning, Sensor Networks, to name only a few.
 One of most successful approaches is Markov Logic, a language that uses
 weighted first order logic to describe Markov Networks of repetitive structure.
 It is one of the most expressive languages as it can describe arbitrary
 Markov Networks.
 Its expressiveness comes at a price: we loose any complexity guaranteees
 that less expressive langauges tend to give.
 If the user designs the 
\begin_inset Quotes eld
\end_inset

wrong
\begin_inset Quotes erd
\end_inset

 model, inference and learning will be painfully slow.
 While often there can be an efficient 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 model for the same task, there are cleary times when this is not the case.
 One example is dependency parsing, where we are required to model relation
 structure that represents projective trees.
 Formulating this in Markov Logic leads to graphical models with very high
 treewidth, and hence high complexity.
\end_layout

\begin_layout Plain Layout
In this work we argue that Markov Logic, in order to scale up, needs to
 
\emph on
open up
\emph default
.
 That is, we propose to generalize Markov Logic to not provide a fixed and
 small set of logical connectives and universal or existential quantification.
 Instead, it should allow users to add their own constructs, such as existing
 Markov Logic building blocks, but also cardinality, projectivity or acyclicity
 constraints.
 The main function of the language is then to provide the glue to assemble
 these constructs.
 At first sight, new building blocks may only be syntactic sugar.
 Markov Logic can, albeit less concise, already express such constraints.
 However, for inference routines that decompose according to the structure
 of our model, the subroutines for these building blocks can often be implemente
d efficiently.
 For example, Belief Propagation essentially requires each factor to marginalize
 itself.
 For a spanning tree constraint this can be achieved in cubic time.
 
\end_layout

\end_inset

In the following we will present 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout
Declarative Factor Graphs, Open.
\end_layout

\end_inset

 an attempt to provide this glue.
 Like Markov Logic
, 
\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 is declarative and focuses on undirected models.
 However, it is not limited to the logical connectives and quantifications
 present in ML; rather, it serves as a framework for extensions such as
 cardinality constraints, or the tree constraint presented here.
 Like FACTORIE, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 supports tailor-made inference, but while FACTORIE is primarily imperative,
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 is purely declarative (for all but language extension designers).
 It is also similar to recent generative approaches, such as Church or Figaro,
 which supprt tailor-made proposal functions.
 However, these languages are a) (primarily) generative, and b) limit themselves
 to MCMC.
 
\end_layout

\begin_layout Standard
We have used 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 it to (a) implement Markov Logic, and (b) extend it with powerful building
 blocks such as a projective spanning tree constraint.
 We show how this extension can be used to implement a syntactic dependency
 parser
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
a dependency parser finds syntactic relations between the tokens of a sentence.
 For example, in 
\begin_inset Quotes eld
\end_inset

the man walks
\begin_inset Quotes erd
\end_inset

 man is the subject of walks, and 
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

 is the determiner of 
\begin_inset Quotes eld
\end_inset

man.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 that would be out of scope for vanilla Markov Logic.
 
\end_layout

\begin_layout Section
Domains, Variables, Worlds
\end_layout

\begin_layout Standard
The glue that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 provides are abstract datatypes for building blocks, as well as a set of
 initial constructs.
 Most Machine Learning infrastructure (inference and learning) can be formulated
 purely in terms of these interfaces.
 We will describe them using classes and traits of Scala
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "odersky08programming"

\end_inset

, a hybrid functional object-oriented programming language.
 
\end_layout

\begin_layout Standard
A 
\family typewriter
Domain[T]
\family default
 contains the (Scala) objects of type 
\family typewriter
T
\family default
 we want to talk about; it needs to provide an iterator over its objects,
 as well as a 
\family typewriter
contains
\family default
 method to indicate Domain membership.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that a Domain can be infinite, and also be used when no enumeration
 of its objects is possible.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The three core types of domains are 
\family typewriter
Values, Tuples, 
\family default
and 
\family typewriter
Functions
\family default
.
 The former simply represents a user-defined set of objects of type T; the
 latter a the set of all functions from a domain to a target.
 
\end_layout

\begin_layout LyX-Code
val Tokens = Values(0,1,2,3,4,5,...)
\end_layout

\begin_layout LyX-Code
val Parses = (Tokens x Tokens) -> Bools 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Ultimately we want to reason about the objects of our domains, using generic
 knowledge independent of their actual identity.
 To do so we need placeholders that allow us to speak about objects in an
 abstract fashion.
 This is generally achieved by variables.
\end_layout

\end_inset

In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 a variable is represented by objects of the class 
\family typewriter
Var[T]
\family default
.
 Each variable has a name and a domain that specifies which values the variable
 can possibly take on.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Variables can be simple (referring to simple objects) or complex (refering
 to functions) :
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
val root = Var(
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

, Tokens)
\end_layout

\begin_layout LyX-Code
val parse = Var(
\begin_inset Quotes eld
\end_inset

parse
\begin_inset Quotes erd
\end_inset

, Parses)
\end_layout

\begin_layout Standard
A variable binding is a (possible) 
\family typewriter
World
\family default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that this is a generalization of possible worlds in Markov Logic if
 one considers bindings of function variables that map into booleans.
 
\end_layout

\end_inset

 Its core method is 
\family typewriter
resolveVar(v)
\family default
 and returns the object the variable 
\family typewriter
v
\family default
 is assigned to.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
or 
\family typewriter
None
\family default
 if no such object exists (for partial worlds)
\end_layout

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To construct worlds we can use 
\family typewriter
MutableWorld
\family default
 objects:
\end_layout

\begin_layout LyX-Code
val world = new MutableWorld
\end_layout

\begin_layout LyX-Code
world(root) = 0
\end_layout

\begin_layout LyX-Code
world(parse) = Map((0,2)->true,(0,4)->true)
\end_layout

\begin_layout LyX-Code
world.close(parse)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Terms
\end_layout

\begin_layout Standard
A term is a symbolic expression that is, given a possible world, evaluated
 to an object.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 a term is an instance of a 
\family typewriter
Term[T]
\family default
 trait that has to implement an 
\family typewriter
evaluate(world)
\family default
 method that maps the binding 
\family typewriter
world
\family default
 to a value of type 
\family typewriter
T
\family default
.
 Crucially, terms in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 also serve as formulae (then they evaluate into booleans) and probabilistic
 models (then they evaluate into real values).
\end_layout

\begin_layout Standard
A simple example term is:
\end_layout

\begin_layout LyX-Code
Exp(Indicator(FunApp(edge,Tuple(root,5)))
\end_layout

\begin_layout Standard

\family typewriter
Indicator
\family default
 evaluates to 1 if the boolean term inside evaluates to 
\family typewriter
TRUE
\family default
, and 0 otherwise.
 The 
\family typewriter
FunApp
\family default
 term applies the result of evaluating the first argument to the result
 of evaluating the second.
 
\family typewriter
edge
\family default
 refers to the 
\family typewriter
Var
\family default
 object we defined earlier and evaluates to the function the variable is
 bound to.
 The other terms are defined accordingly.
 
\end_layout

\begin_layout Standard
We will use Scala's syntactic sugar to make code more concise.
 In our case we can use this to alternatively write
\end_layout

\begin_layout LyX-Code
exp(${edge(root,5)})
\end_layout

\begin_layout Standard
where 
\family typewriter
${
\begin_inset Formula $\cdot$
\end_inset

}
\family default
 is the indicator function.
 
\end_layout

\begin_layout Standard
To support abstraction, we provide quantified operations that are applied
 to all objects of a given domain.
 For example, to evaluate 
\end_layout

\begin_layout LyX-Code
Sum(Tokens,i=>${tag(i,VB)->edge(root,i)})
\end_layout

\begin_layout Standard
we replace i in the inner term with each possible value in 
\family typewriter
Tokens
\family default
, then we evaluate the inner term, get a real value, and sum up these values.
 It should be clear that by placing this term into the exponential function
 we have an (unnormalized) MLN.
 Also note that by replacing the add operation with 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

and
\begin_inset Quotes erd
\end_inset

 we get existential and universal quantification.
\end_layout

\begin_layout Standard
Terms are the main building blocks of probabilistic models.
 For most users, working with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 means composing terms into more complex terms, and use them to describe
 probabilistic models.
 Some users, however, will design and implement new terms.
 In our running example, one could add a projective spanning tree constraint
 
\family typewriter
PTree
\family default
:
\end_layout

\begin_layout LyX-Code
${edge(root,5)}*PTree(edge,root)
\end_layout

\begin_layout Standard

\family typewriter
PTree(edge)
\family default
 returns 1 if the function in 
\family typewriter
edge
\family default
 corresponds to a spanning tree over objects in 
\family typewriter
Tokens
\family default
 rooted at 
\family typewriter
root
\family default
, and 0 otherwise.
 Hence the above term will return 1 iff 
\family typewriter
edge
\family default
 is a spanning tree and if the 
\family typewriter
root
\family default
 value is linked to token 5.
 
\end_layout

\begin_layout Section
Inference
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Introducing an own term for spanning tree makes our model more concise.
 More importantly though, it also makes inference more tractable.
 To illustrate this let us look at the case of Belief Propagation.
 
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "smith08dependency"

\end_inset

 have shown how efficient dynamic programming methods can be used to calculate
 the outgoing messages of a projective tree constraint factor.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 we allow the inference engine to make use of this.
 When the language designer adds a new term, he can also override a 
\family typewriter
message
\family default
 method that calculates its outgoing messages during BP.
 
\end_layout

\begin_layout Plain Layout
Note that this type of compositional inference is not exclusive to Sum Product
 BP, and the spanning tree factor.
 Similar approaches can be used for algorithms such as Max Product BP
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Duchi07usingcombinatorial"

\end_inset

 or methods that do not unroll the full graph.
 For example, quantified terms can have a 
\family typewriter
separate
\family default
 method for Cutting Plane Inference
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "riedel08improving"

\end_inset

 that returns all factors that are not 
\emph on
maximally satisfied
\emph default
 in a given world.
\begin_inset Note Note
status open

\begin_layout Section
Related Work
\end_layout

\begin_layout Plain Layout
Like Markov Logic 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 is declarative and focuses on loglinear models.
 However, it is not limited to the logical connectives and quantifications
 present in ML; rather, it serves as a framework for extensions such as
 cardinality constraints, or the tree constraint presented here.
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that alchemy supports user-defined functions, but not 
\end_layout

\end_inset

 The possibility of incorporating tailor-made inference is also present
 in FACTORIE
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mccallum09factorie"

\end_inset

; But while FACTORIE focuses on imperative constructs, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 is primarily declarative and requires imperative coding only for extension
 designers.
 In this sense it is actually close languages like Figaro or Blog, which
 allow inclusion of tailor-made proposal functions.
 However, these languages are a) primarily generative, and b) limit themselves
 to MCMC.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Results and Conclusion
\end_layout

\begin_layout Standard
To show the dramatic impact that these tailor-made terms can yield, we compared
 a model with PTree constraint to a model that uses FOL formulae to achieve
 the same.
 For sentences longer than 10, our speed-ups were dramatic: ....
\end_layout

\begin_layout Standard

\size small
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/Users/riedelcastro/projects/papers.fresh/bibtex/riedel"
options "aaai"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
