next:
	- Substitution
	- SQLQueryGenerator (ReflectiveProducer<Formula,SQLQuery>)
	- Relation should be interface with the following implementations
	  - UpdatableRelation (subinterface)
	  - SQLBasedRelation (implements UpdatableRelation)
	  - UnmodifiableRelation (delegates to UpdatableRelation)
	- Signature should be interface with the following implementations
	  - UpdatableSignature
	  - SQLSignature
	  - UnmodifiableSignature (delegates to UpdatableSignature)
	  - SubSignature (shows only a few predicates)
	- World
	  - SQLWorld
	  - SubWorld (stores relations of a subsignature
	- SQLQuery: sql query, parametrized by world.


Restrict Markov Horn Logic (Conditional Clausal Markov Logic)
- must be groundable to clause of hidden ground atoms
- => first order formula is disjunction of literals and conditioned existential quantifiers over single literals:
  - p(x) v exists y [o(y) ^ k(y)]: q(x,y)
- => Markov Logic defines set of allowed hidden predicates (above o(y) must be observed)

- first order formula must be: at most one positive literal or conditional existential quantifier. 

Body: list of atoms. (negated in clause)
Head: atom + condition + existential variables

h(x1) :- q(x1) 
-> exists e1. h(e1) [e1=x1] :- q(x1)

exists e. h(e) [e=x] :- p(x)
exists l. role(p,a,l) :- hasRole(p,a)
exists h. dep(h,m) [word(h)]:- word(m)
//if you want to prove for a given m whether there is a h with dep(h,m) & word(h) you need  to prove word(m)

exists dep(h,m) & word(h) :- word(m)

=> if weights are positive number of violated ground formulae is always bound by size of current solution.


GeneralizedClause {
    List<Atom> head;
    List<Atom> body;
}

forall x,y k(x,y) => exists z l(x,y,z) 



Functions:
parsed(np(x1,x2)) & parsed(vp(x2,x3)) => parsed(s(x1,x3)) 
parsed(np) & parsed(vp) => parsed(s(np,vpo))
-> Allow compound types and functions that map into it
Type Constituent: Compound;
function tag: Tag -> Constituent;
function node: Label x Constituent x Constituent -> Constituent;

tagged(x, t) => parsed(x, x, tag(t))
parsed(x1,x2,+n1) & parsed(x2,x3,+n2) => parsed(x1,x2,+n3)

@predictor("tnt")
TnT extends AnnotablePredictor {
	@bind("word")
	UserPredicate word;
	@required("tag")
	UserPredicate tag
}
->

@bind("tnt","tag") 
pos: Int x Pos;

@required("tnt", "word")
word: Int x Word;


//real online learning
- new formulas are added on the fly
- current world is hypothesized
- current world is compared to a reference world (can be partially hidden)
- weights are updated.
- formulae that have near-zero weights will be removed gradually.

//code in solver
@param w a world that only contains predicates this solver is bound to
or depends on. Only the predicates the solver is bound to are updatable. 
solve(World w, ChangeList cl){
	    World sandbox = w.clone();
	    //make changes to the bound relations in the sandbox
	    change(sandbox)
	    //write changes to the actual world. Creates one atomic changed event.
	    world.copyFrom(sandbox);
}

World {
      getRelation
      getUpdatableRelation
}

Solver {
       //only sees a view of the world containing the predicates it depends on.
       solve(World, Map<UserPredicate, UpdatableRelation> dst)
}

Sensor {
       sense(Map<UserPredicate,UpdatableRelation> dst)
}

Background {
	inject(Map<UserPredicate,UpdatableRelation> dst)
}	

Effector {
       act(World w);
}


!action(x)
state(Updated) -> action(Next) //changes counter
counter(1) ^ goal(G) -> action(A)
counter(2) ^ goal(G) -> action(B)
counter(3) ^ goal(G) -> action(C)

Beast loop:
      1) All predicates tagged as action relations are refreshed/updated
      2) Actions (action predicates) in the MAP world are performed (in no specified order)
      3) Observed predicates are updated

User mode:
     1) Manually Update some observed predicates
     2) Call a query.

Beast Class: object with
      - Signature
      - MLN
      - Set of plugins bound to predicates
      - Set of possible worlds.
      - Set of Effectors (actions)
      - Set of Sensors (observations)
      
Beast b = new Beast();
Sensor s = new DatasetSensor("data.file")
Solver p = new CPISolver();
b.bindBackground(new BackgroundFromFile("back.file"), {unique})
b.bindSensor(s, {lemma,pos,word})
b.bindSolver(p, {role, hasRole})
b.loadMLN("mln.file")

s.next();
b.getWorld().query("role(x,y)");

Sensor s = new DataSetSensor("data.file");

World w = b.get




lazy evaluation: each relation is only evaluated when needed (i.e. when a parent relation is queried). At that point calculating the relation can either be done by reading the complete state of the dependend relations or by processing the remembered changes. 

	predicate.refresh(){
		if (dependenciesNotPossiblyChanged) return;
		dependencies.refresh()
		plugin.update(relation)
	}

Beast:
	goal based back tracking.
	example goals: {PrintAtoms 	

Goals:
	Query  
	RelationUpdate 
	Action {like PrintAtoms}

Procedure: Sequence of goals
Test: Loop {Observe, Ask, PrintAtoms, Compare}
Train: Loop {Observe, Ask, Remember}, Estimate 

thebeast model file:
type Type: A,B,C;
predicate pred: Int x Int;
plugin tnt: com.tnt.TnT;
<formula-template>;

plugin provides its dependencies. For example, CPI's dependencies are all
predicates that a) are not bound to the plugin and b) appear in formulae together 
with the bound predicates. 	 

plugins cannot be bound to predicates that are required by its (transitive) dependencies.

StaticFunction {
	 Constant evalConstants(Constants)
	 SQLTerm evalSQLTerm(SQLTerms)
}

StaticPredicate {
	boolean containsConstants(Constants)
	SQLCondition containsSQLTerms(SQLTerms)
}

QueryEngine {
	Bindings resolve(Query, World)
	Bindings resolve(Query, Dataset)	  
}

todo:
	- WorldListener
	- Predicate Inheritance
	- Context: set of ground atoms true in every possible world.

f_M,C(y) = f_M(y & C)


World {
      // -> the relation for the given predicate is calculated by
      // the given plugin
      // can only happen before getRelation is called first
      // once the predicate is bound calls to getRelation will
      // return unmodifiable relations (views on the actual relation).
      bind(UserPredicate, PredicatePlugin);
      getRelation(UserPredicate)
            

      package visible:
      //requires the state of the corresponding relation to be updated
      //called by the query engine. 
      refresh(UserPredicate)
      
}

// make sure a plugin has only access to its dependencies
PredicatePlugin {
	//when this method is called it is clear 
	update(Relation target, Map<String,Relations> dependencies) 
	tuplesAdded(String name, Tuples tuples);
	tuplesRemoved(String name, Tuples tuples)
	tuplesChangedCompletely(String name)
	UserPredicates getDependencies();
}


package thebeast.plugin; //decoupled from world.

//is called whenever clients request read operations on
//a relation bound to the plugin or a query calls the
//refresh method on a relation.
PredicatePlugin implements WorldListener {
      setWorld(world)
      update(UserPredicate, Relation);
      updateNBest(UserPredicate, Relations)
} 

@Bind("Path") @path.graph("dep") 
predicate path: Int x Int x Path;

@Bind("CPI")
@Hidden @RequiresHidden("pos")
predicate dep: Int x Int;

@Bind("MultiClass")
@Hidden
predicate pos: Int x Pos;


Beast {
      addSource(DataSource)
      addSink(DataSink)
      addBackgroundKnowledge(BackgroundKnowledge)
      setMLN(MLN mln)
      setWeights(Weights weights)
      bind(UserPredicate, Plugin);
      addTask(Task)
      learnBackground();
      learnStructure();
      learnWeights();
      infer();

}







f_M(x_i,y_i,c_i) with c_i = t(x_1,..,x_i-1,M)

View Markov Logic Network as a way to define a mapping from a possible world to an (countable infinite/finite) real valued vector. Weights + MLN = mapping from possible world to score/probability. MLN: maps symbolic world into subsymbolic.

mln(y) = \sum_{f}\sum_{b} e_b[id] * b[scale] * I[f[b] satisfied in y]

Markov Theta Logic
- assumes fixed signature (not parametrized by set of constants)
- parametrized by weight vector		    
- each grounding of a formula can have a different id (different weight)
- each grounding of a formula can hava a different scaling factor.
- cardinality constraints
- (acyclicity constraint)

Markov Theta Template 

formula with no free variables: pred(C) -> singleton(x) & pred(C)

deterministic formula: pred(x) -> id = 0 & pred(x) ^ scale=1 [scale * theta(0)]

thus exp(p(y)) ~ <w,mln(y)>

MLN{
	FeatureVector getFeatureVector(World w);
}

Deterministic predicates:
-eg. path: requires some configuration
  
  @deterministic(graph.path) @path.uses(token) @path.args(0,1) @path.length(2)
  predicate path;

Data management options:
1. 
   - Each possible world has set of db tables and owns them until destruction.
   - a dataset stores possible worlds using one table per predicate (with extra world id column)
   - A SQLTablePool maintains tables and allows reuse of tables to avoid expensive table creation etc. 
   - A SQLTable maintains a mapping from ML Queries to SQL queries to avoid recreation of queries.
   

PML syntax:
  - (higher order) functional
  - cardinality, existential and universal qualification
  - disallow conjunctions of disjunctions or disjunctions of conjunctions 
  - cycle constraint

AlchemyExpression -> TemplateExpression -> Expression
Template -> Expression(s)
equals(1,2) -> equals.int(1,2);
equals(1,2.0) -> equals.double(cast.int2double(1),2.0);

formula regex templates:

//multiclass
\observed ^ |l: \hidden(*,l,*) | <= 1; 

//local features
(\hidden) ^ \local* 
(\hidden) v \local*

//linear chain
\hidden(*,t,*) ^ \hidden(*,t+1,*) ^ \observed*

preprocessor
@param(T,"word")
T(x,+p)=>label(x,+l)
-> _weight(p,l,id) & word(x,p) & scale = 1 => label(x,l) [scale * theta(id)]

label(Int,Label)
-> predicate label: Int x Label (in alchemy mode).

alchemy style:
	Label = {A1,A2}
	label(Int, Label) // predicate def.
        label(x,y) //formula def.

AlchemyExpression (label(Int,Label))
	- Atom
	- TypeDefinition

Template
	- TypeDef
	- PredicateDef
	- Formula
	

MarkovLogicExpression
	- TypeDef, Formula
	- WeightedFormula
	
	

PML semantics:
A possible world:
  - maps each constant to itself
  - maps each predicate symbol to a relation
  - maps each function symbol to function of constant tuples
formula is satisfied
  - if formula where all function applications are recursively replaced by their corresponding fixed value is true 

Condition query:
  - find all variable bindings for which the hidden predicates have an effect on the formulas truth state
  - inner quantifiers are searched for all conditional assigments, too.

 o1(x) & h1(x) & forall y: o2(y,x) v h2(y) 

possible world variable

score(w,s) & s > 0.01 & o1(x)#w
w 	     s 	 x
1	     0.12	 A1

= find all x with o1(x) and for each x find all y with !o2(y,x)
example solution:
   - {(x/1,{y/1,y/2,y/3}),(x/2,{y/5,y/10})} 


Weights:
	- double vector

ground formula using binding: replace top level variables, expand quantifications



package structure:
   com.googlecode.thebeast (org.markovthebeast.thebeast)
	formula
		Interpreter, Term, And, Or, CardinalityConstraint
	world
		Signature, Type, Constant, World, Dataset, IntConstant, ..., Add.Int,
	signature
		Value, Predicate, Type, Function, Constant, Signature
	builtin
		Add, Equals, ...
	parse
		Parse, Preprocessor, Parser
	solve
		LocalSolver, CPISolver
	learn
		OnlineLearner, LossFunction,...	
	world
		Dataset, World
	weights
		Weights (?)
	shell
		GroovyShell
	mln
		MLN, WeightedFormula
	ground
		GroundMarkovNetwork, GroundQueryGenerator, Node, Feature ...
	fixture (test tree)
		SRLFixtures, AlignmentFixtures, ERFixtures


WeightedFormula {
	Variable getIdVariable();
	Variable getScaleVariable();
	Formula getFormula();
	Formula getConditionalFormula();
}

Binding {
	Constant getConstant(Variable);
	Binding getBinding(Quantified);
}



b = new Binding("x/2,y/3,forall a,b. p(a,b):<{a/2,b/3},{a/1,b/2}>");

typical workflow: (training)
	Memory mem = new Memory("memfile.db");
	mem.addType("Label");
	mem.addPredicate("label(Int, Label)");
	mem.addPredicate("word(Int, Word)", true);
	World w = mem.createWorld();
	w.addAtoms("label(0,"TMP")");
	w.loadAtoms(file);	
	w.query("label(x,y)");
	w.commit();
	MLN mln = mem.createMLN();
	mln.load("mln.pml");
	Weights weights = mem.getWeights();
	World global = mem.getGlobal();

	Dataset d = mem.createDataset(transient);
	collector.collect(d,weights);
	learner.learn(d,weights);
	...
	mem.setGlobal(weights);
	mln.store(...); //stores mln + memory


(testing)
	MLN mln = MLN.load(...); //loads memory
	Memory mem = mln.getMemory();
	Solver solver = new PipelineSolver(...,mln);
	Dataset testCorpus = mem.loadDataset("dataset.atoms");
	Dataset result = mem.createDataset();
	for (World w: testCorpus) solver.solve(w,result.createWorld());
	
	Dataset compare = mem.createDataset();
	compare.add(testCorpus.get(0).clone(),"gold");
	compare.add(result.get(0).clone(), "guess");
	compare.query("label(x,y)~gold & !label(x,y)~guess");
	compare.query("!label(x,y)~gold & label(x,y)~guess");


-> saving full state and signature in memory object, no need to reload definitions.
-> MLN becomes component. 



	
Solver {
       init(MLN);
       solve(World, World);
       solveNBest(World, Int, Dataset);
}	
	
			

		     

	
	

MLNPreprocessor:
  - extends MLN using annotations such as formula templates, etc.

@name("test") @param("T","word,tag,lemma") 
T(x,!t) => label(x,!l)
//creates formulas with name test_word, test_tag etc.

@name("labelWindow")
@param("C","1,0,-1") 
@param("T","word,pos,lemma") 
@order(12)
T(x+C,!t) => label(x,!l)


Parse: 
 - not interpreted PML expression
 - (can have a parent Parse from which it was created via substitution)
 - can have resource URL and line number

Expression: interpreted (can have a parent Parse from which it was created via interpretation)

Parser: takes String creates Parse
Preprocessor: takes Parse creates new Parse(s) (is aware of some semantics)
Interpreter: takes Parse creates Expression

PossibleWorld:
- can have parent possible worlds. If so, it inherits all ground atoms from the closed world predicates of that world
- potential parent worlds:
   - global world with static information
   - weight world with weights 
   - observation world (multiple solutions share the same observation world)

group.addParentWorld(weight);
group.addParentWorld(global);


Weighted Formula:
- FOL formula + designated id variables that give grounding id and designated double
  variable that scales weight 
  - word(x,w) & weight(w,id) & scale=1 &  !pre=prefix(w) [scale * weight(id)] 

preprocessor:
    word(x,!w) => label(x,!l) 
to
    word(x,w) & _weight1(w,l,_id) & scale = 1.0 => label(x,l) [scale * weight(_id)]


id can come from anywhere but would usually be bound via weight predicate that can be implicitely added.

PossibleWorld weights = mem.createWorld();
PossibleWorld observation = mem.createWorld(weights);
Bindings bindings = mem.query(formula.all(), observation);

Memory:
- manages a set of possible worlds
- term evaluation
- normal queries
- recursive queries (all assignments + all true assignments for inner quantified formulae, note that replacing exists with forall and vice versa yields the same result).
- recursive conditional queries (all assignments + all inner assignments only if inner formula holds/doesn't hold)

ShortTermMemory/Focus:
- represents a view on the Memory that focuses on a specific possible world
- queries are implicitely using the possible world in focus
- modifications can be made but need to be commit in order to become visible in parent memory
- does not allow queries over multiple possible worlds
- creating a focus locks the possible world for further changes from elsewhere

MidtermMemory/Dataset/Corpus/Group:
- represents a subset of the memory
- possible worlds can be added
- changes must be commited to become visible in memory
- locks all its possible worlds for futher changes from elsewhere (also disallows creation of other views/focuses)

Memory m = new Memory();
Group g = m.createGroup();
Focus f = g.createFocus(g.createPossibleWorld())
f.query("p(x)");
f.addAtoms("p(1)");
f.commit(); //commit changes to group
g.addAtoms("p(1)#$1, p(5)#2",1); //add atom to world 2 without creating a view
g.commit(); //commit changes to long term memory

o1(x) & exists y. o2(x,y)

GroundMarkovNetwork:
  - ground(weightedformula, bindings)
  - getNodes();
  - getEdges();...
  - addListener(...)

mn.ground(f,f.all(world));
for (f : mln.withPreds(preds)) mn.ground(f,f.all(world));

GroundQueryGenerator:
  - createConditional(weightedformula)
  - createRecursive(..)
  - createRecursiveConditional(..)
  - createSeparationRecursive(..)
  - ...

LocalSolver:
  - takes a definition of hidden predicates and observed ones
  - grounds network with local formulae wrt to the hidden predicates
  - choses ground atoms by local score

MultiClassSolver
  - accepts @multi annotation for multinominal variables (or inspects formulae)
  - groups nodes in network according to multiclass definitions and picks best atom in group

GroundNetworkSolver
  - fully grounds wrt to observed and hidden predicates and runs MN Map inference

CPISolver:
  - CPI 

PipeLine
  - has n solver and i-ths solver creates possible world for i+1 solver.   

NBestPipeline
  - if solver supports multiple candidates pass them on to next solver and multiply candidates. Possibly prune.

Reranker
  - takes a few possible worlds and evaluates they score, reranks accordingy.

GreedySolver:
  - maintains a set of ground atoms which are fixed
  - alg:
    1. creates new ground atom (according to some heuristic)
    2. instantiate all ground formulas between new ground atom and fixed atoms
    3. pick state of new ground formula by optimizing sum of weights of those features.
    4. add new atom to fixed atoms, go to 1. 

Conditionalization:
- transform a formula into two parts: one fully observed and one hidden (partially)

a(p) & p(x) satisfied if p in a and x in p 

a(p) & p(x) => p(x) if a(p) otherwise skipped

PML annotations:
- annotate predicates with processing hints (such as @linear or @mst)
- annotate formulas with processing hints 

Constraints:
  - the interpretation of a function symbol is known in advance and identical for all possible worlds
  - for all higher order predicates closed world assumption (if not explicitely specified predicate is false)
	 



For every f in Vocab: dom(I(f)) subset of Vocab, img(I(f)) subset of Vocab

I_y(forall x. phi) = True if forall x I_y(phi[x]) = true) 
I_y(constant) = constant
I_y(f a) = b if I_y(f) (I_y(a)) -> b in y else f_default
 

Allow special annotations to indicate sequential predicates, tree predicates etc.:

//is a 1st order markov linear chain
@markov(1) 
pos(Int,Label);

@mst.edge 
link(Int,Int)

@mst.label
label(Int,Int,Dep);

Assume I implement a one layer viterbi search:
// instantiate active local features
mn.ground(mln,"pos(t,l)", "local", "order by t,l");
// instantiate active features that connect consecutive predicates
mn.ground(mln,"pos(t,l1), pos(t+1,l2)", "next", "order by: t"); 
// instantiate active features between labels of same token. 
mn.ground(mln,"pos(t,*)", "label", "order by: t");

// create viterbi network
for (Int t = 0; t < mn.getPartition("label").size(); ++i)
    addToViterbiNode(t, mn.getPartition("label",t));
    for (int l = 0; l < mn.getPartition("local").size(t); ++l)
    	addToViterbiNode(t, mn.getPartition("local",t,l));
    if (t > 0) addViterbiEdge(t,mn.getPartition("next",t);

// solve viterbi
solveViterbi();
// return possible world
return possibleWorld();

Implement MST parser
mn.ground(mln, "link(h,m)", "local", "order by h,m");
mn.ground(mln, "edge(h,m,l)", "local-edge", "order by h,m");
... 


// 
// that have at least one active feature
// get all connections vertical connections (between labels)
// get all horizontal connections between tokens
// map to viterbi search


class TheBeast {
      MutablePredicate createPredicate();
      Type createType();
      Value eval(Expression expr);
      ValueSet query(OpenExpression expr);  
      PossibleWorld createWorld();      
}



interface Type extends Iterable<Value> {
      boolean supportsIteration();
      Collection<Type> getSuperTypes();
      Collection<Type> getSubTypes();
      String getName();     
}

class ConstantType implements Type {
      
}

class FunctionType implements Type {
      //iterates over all functions defined with this type
      //automatically deduces subtypes (by consistent signature)
}

class PossibleWorld {
      SQLDatabase getDatabase();      
}

class GroundMarkovNetwork{
      Features ground(WeightedFormulas);
      Features ground(WeightedFormulas, OpenExpression)
}

class Feature {
      int getIndex();
      Function getFunction();
      WeightedExpression getFormula();
      Nodes getNodes();
      Function 
}

interface Value {
	  String getName();
	  Type getType();
}

interface Function extends Value {
	  Function apply(Function  arg, PossibleWorld world);
	  ValueSet invert(Function result, PossibleWorld world);
	  SQLTerm applySQL(SQLTerm  arg);
	  SQLTableTerm invertSQL(SQLTerm arg, SQLTerm result);
	  String getInfixSymbol();
}

class Constant<T> implements Value {
      	  T value();	       
          Function apply(Function arg){ return this;}
	  SQLTerm applySQL(SQLTerm arg) {return SQLString(value.toString()); 
	  String name() { return value.toString();}		             
}

class LambdaFunction implements Function {
      Expression getExpression();
      Variables getVariables();
}

class Constants {
      Constant<Integer> i(int);
      Constant<Double> d(double);  
      Constant<Boolean> b(boolean b);
      Constant<Boolean> tru();   //b(true);
      Constant<Boolean> falz();  //b(false);  
}

class Tuple implements Function {

}

class MutablePredicate implements Function {
}
class MutableFunction implements Function {
}

//function that maps a set of boolean values to the number the value "true" appears in the set.
class Count implements Function;

class Functions {
      Function add();
      Function equals();
      Function and();
}

class Expression;
class Variable extends Expression;
class FunctionApplication extends Expression;
class WeightedExpression extends Expression; //has scale and weight term

class Expressions {
      Expression apply(Expression);
      Expression var(String name);
      
}



lambda x. p1(x,5);

select t1.col1 from (select * from p1) t1 where t1.col2 = 5

lambda x. p1(x,5) ^ p2(x+1) = lambda x. and(p1(x,5),p2(x))

select t1.col1 from (select * from p1) t1, (select * from p2) t2 where t1.col1 = t2.col1 and t1.col2 = 5;

invert add: select t1.col1,t2.col2 from Int t1, Int t2 where t1.col1 + t2.col = 5

TheBeast beast = new TheBeast();
beast.createType("Token",1,2,3,4,5);
beast.createPredicate("word", "Token", "Word");
PossibleWorld world = beast.createWorld();
world.addAtom("word", 1, "the");
Function result = beast.eval("word(1,"the"), world);
FunctionSet query = beast.query("word(x,y)", tru(), world); 

MLN mln = beast.createMLN();
WeightedFormula f = mln.add("word(x,!w)=>tag(x,!t)"); //adds formula and corresponding weight function

//higher order
CPISolver solver = new CPISolver(mln);
PossibleWorld best = solver.solve(world); 
VectorSpace vs = mln.getVectorSpace();
FeatureVector fv = vs.toFeatureVector(best);

//propositional
GroundMarkovNetwork mn = beast.createGroundMarkovNetwork();
MaxProductSolver mp = new MaxProductSolver(mn);
Nodes nodes1 = mn.groundAtoms("tag(x,"DT") : x < 10");
Nodes nodes2 = mn.groundAtoms("tag(x,"DT"),word(x,y) : x < 10");
mn.groundFormula(f, world);
mn.groundFormula(f, nodes); //return all 
//or
mn.ground(mln);
PossibleWorld w = mp.solve();


//second order expr (type automatically resolved because of type information for tag
f(t,Value:v)=>tag(t,l) 
//typed version
Token t, Value v, Label l, (Token,Value) f: f(t,v)=> tag(t,l)









