#LyX 1.5.2 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
\usepackage{hyperref}
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter courier
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\end_header

\begin_body

\begin_layout Title
Markov TheBeast User Manual
\end_layout

\begin_layout Author
Sebastian Riedel
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Chapter
Installation
\end_layout

\begin_layout Standard
Download the archive and extract it using 
\end_layout

\begin_layout LyX-Code
$ tar xvf thebeast-0.x.y
\end_layout

\begin_layout Standard
This will create a directory thebeast-0.x.y which we will refer to as the
 THEDIR.
 Change into THEDIR and call 
\end_layout

\begin_layout LyX-Code
$ ant -f thebeast.xml
\end_layout

\begin_layout Standard
This compiles the source.
 You can now call thebeast executable by calling
\end_layout

\begin_layout LyX-Code
$ $THEDIR/bin/linux/thebeast
\end_layout

\begin_layout Standard
if you are running linux, or 
\end_layout

\begin_layout LyX-Code
$ $THEDIR/bin/mac/thebeast
\end_layout

\begin_layout Standard
if you run a mac.
 
\end_layout

\begin_layout Section
Hints
\end_layout

\begin_layout Enumerate
You can simplify your workflow by adding ..bin/linux/ or ../bin/mac to your
 Path
\end_layout

\begin_layout Enumerate
You're free to move and rename THEDIR.
 
\end_layout

\begin_layout Chapter
The Shell
\end_layout

\begin_layout Standard
Most likely you will communicate with thebeast
\begin_inset Foot
status collapsed

\begin_layout Standard
Alternatively, you can use the java API.
\end_layout

\end_inset

 using 
\emph on
theshell
\emph default
 (in short 
\emph on
the
\emph default
-
\emph on
sh
\emph default
): a very simple scripting language and interpreter that allows to access
 all the essential functionality of the beast.
 It can be used to 
\end_layout

\begin_layout Itemize
define models
\end_layout

\begin_layout Itemize
learn parameters
\end_layout

\begin_layout Itemize
do inference
\end_layout

\begin_layout Itemize
set parameters
\end_layout

\begin_layout Standard
You can start the-sh by simply calling
\end_layout

\begin_layout LyX-Code
$ thebeast
\end_layout

\begin_layout Standard
This leaves you with a prompt like 
\end_layout

\begin_layout LyX-Code
Markov TheBeast v0.x.y
\end_layout

\begin_layout LyX-Code
# 
\end_layout

\begin_layout Standard
Alternatively, you can save your script in a file, say test.thesh, and execute
 this script directly via
\end_layout

\begin_layout LyX-Code
$ thebeast test.thesh
\end_layout

\begin_layout Standard
In the following we will give an high level overview of the main components
 and commands of the shell.
 For details on defining models, learning, inference we refer the reader
 to the later chapters.
 
\end_layout

\begin_layout Section
Architecture
\end_layout

\begin_layout Standard
theshell can be seen as a collection of components and resources.
 thesh commands can configure components and control them to process resources.
 Figure 
\begin_inset LatexCommand ref
reference "fig:architecture"

\end_inset

 gives a schematic overview of these components and resources.
 In the middle we see core components of theshell, the learner, solver and
 collector.
 Roughly speaking, the collector instantiates features, the learner learns
 weights and the solver applies a trained model to data.
 They all use or modify the 
\emph on
signature
\emph default
, a collection of types, predicates and functions, the 
\emph on
model, 
\emph default
a collection of formulas, and 
\emph on
weights
\emph default
, a collection of real numbers that determine with how much penalty formulas
 can be violated.
 The data used for training and testing comes from the 
\emph on
corpora
\emph default
 and guess and gold atoms.
\end_layout

\begin_layout Standard
The remainder of this book will explain all these components, resources
 and interactions in more detail.
 In this chapter we will continue to give a high level overview of the component
s and resources.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/architecture.eps
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:architecture"

\end_inset

A schematic overview of the components and resources within thesh.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Section
Signature
\end_layout

\begin_layout Standard
Before doing anything, we need to define the types, predicates and functions
 that our model uses.
 All data has to adhere this signature.
 There are three types of definitions 
\end_layout

\begin_layout Description
Type defines a set of constants
\end_layout

\begin_layout Description
Predicate defines a predicate over the cartesian product of some types
\end_layout

\begin_layout Description
Weight-Function defines a mapping from tuples to double values
\end_layout

\begin_layout Standard
The shell only maintains one single signature.
 Every definition is added to this signature.
 
\end_layout

\begin_layout Standard
Chapter 
\begin_inset LatexCommand ref
reference "cha:Signatures"

\end_inset

 gives more details on signatures.
\end_layout

\begin_layout Section
Model
\end_layout

\begin_layout Standard
Using the predicates, types and functions of the signature we can define
 a model.
 A model consists of several formulas which assign scores (or probabilities)
 to substructures of a solution.
 As with signatures, the shell only maintains on global model.
 Each new formula is added to this model and all components share this model.
\end_layout

\begin_layout Section
Corpora
\end_layout

\begin_layout Standard
The Beast needs data to learn weights from, to process during testing and
 for inspection and analysis of errors.
 This data comes from a corpus.
 A corpus is a sequence of databases.
 In thesh we have two corpora, the 
\emph on
working corpus
\emph default
 and the 
\emph on
inspection corpus
\emph default
.
 Which to use depends on what you want to do with thebeast.
 you can find more details on corpora in chapter 
\begin_inset LatexCommand ref
reference "cha:Corpora"

\end_inset

.
\end_layout

\begin_layout Subsection
Working Corpus
\end_layout

\begin_layout Standard
The working corpus is used for training weights and testing a model, that
 is, applying the model to data.
 In general, the working corpus is saved on file and streamed in one by
 one, thus only needing a small amount of memory.
 
\end_layout

\begin_layout Subsection
Inspection Corpus
\end_layout

\begin_layout Standard
The inspection corpus is used for analyzing the behaviour of the current
 model.
 The inspection corpus comes along with 
\emph on
current gold database
\emph default
 which can be loaded from any position in the corpus.
 We can seek forwards and backwards within the inspection corpus and print
 out the current database, apply the model it and compare the results of
 our model with the original gold data provided.
\end_layout

\begin_layout Standard
The inspection corpus fully resides in memory.
 Any database within can be randomly accessed.
 
\end_layout

\begin_layout Section
Getting and Setting Parameters
\end_layout

\begin_layout Standard
As mentioned above, theshell also provides means to configure components
 and set parameters.
 This is achieved using the 
\emph on
set
\emph default
 command.
 Each component has name and a set of named properties.
 For example, the solver is named 
\begin_inset Quotes eld
\end_inset

solver
\begin_inset Quotes erd
\end_inset

 and has a parameter 
\begin_inset Quotes eld
\end_inset

maxIterations
\begin_inset Quotes erd
\end_inset

.
 We can set this parameter by 
\end_layout

\begin_layout LyX-Code
set solver.maxIterations = 10;
\end_layout

\begin_layout Standard
We will give the names and parameters of components in the following chapters.
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Signatures"

\end_inset

Signatures
\end_layout

\begin_layout Standard
Every model maintains a 
\emph on
signature
\emph default
, a collection of symbols to be used in the formulas that describe the domain.
 
\end_layout

\begin_layout Section
Types
\end_layout

\begin_layout Standard
TheBeast allows typed predicates and formulas.
 That is, constants are divided into sets (types) and predicates are defined
 over Cartesian Products of these types.
 
\end_layout

\begin_layout Standard
Say we want to perform Semantic Role Labelling.
 Here we are asked to label constiuents of a parse tree with the semantic
 role these constiuents play with respect to a given verb of the sentence.
 For example, 
\end_layout

\begin_layout Quote
[
\begin_inset Formula $_{\text{A0}}$
\end_inset

He] [
\begin_inset Formula $_{\text{AM-MOD}}$
\end_inset

would] [
\begin_inset Formula $_{\text{AM-NEG}}$
\end_inset

n't] [
\begin_inset Formula $_{\text{V}}$
\end_inset

accept] [
\begin_inset Formula $_{\text{A1}}$
\end_inset

anything of value] from [
\begin_inset Formula $_{\text{A2}}$
\end_inset

those he was writing about] .
\end_layout

\begin_layout Standard
is a sentence that has been role-labelled wrt to the verb 
\begin_inset Quotes eld
\end_inset

accept
\begin_inset Quotes erd
\end_inset

.
 Here the roles names are generic terms that have different meanings for
 different verb: A0 refers to the acceptor, A1 refers to the thing being
 accepted and so forth.
 
\end_layout

\begin_layout Standard
In this setting it will come in handy to define a type label as follows
\end_layout

\begin_layout LyX-Code
type Label: A0,A1,A2,
\begin_inset Quotes erd
\end_inset

AM-MOD
\begin_inset Quotes erd
\end_inset

,''AM-NEG
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

somelabel
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Standard
Note that constants are
\end_layout

\begin_layout Itemize
either words starting with a capital letter adn without any special characters
 or
\end_layout

\begin_layout Itemize
quoted strings
\end_layout

\begin_layout Standard
Type names have to be capitalized.
\end_layout

\begin_layout Standard
It can be tiresome to define all constants of a type in advance, especially
 when they are already specified implicitely in your training data.
 To make life easier thebeast allows you to write
\end_layout

\begin_layout LyX-Code
type Label: ...
 ;
\end_layout

\begin_layout Standard
In this case the type is automatically augmented whenever a new constant
 is encountered.
 However, in order to reuse a model that has been trained using these open
 types one has to make sure to call 
\end_layout

\begin_layout LyX-Code
save types to 
\begin_inset Quotes eld
\end_inset

<filename>
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Standard
after training and to load the generated script file before testing with
 
\end_layout

\begin_layout LyX-Code
include 
\begin_inset Quotes eld
\end_inset

<filename>
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Subsection
Built-In Types
\end_layout

\begin_layout Standard
Thebeast comes with a set of buillt-in types.
 For now these only include an integer type
\end_layout

\begin_layout LyX-Code
Int
\end_layout

\begin_layout Standard
and a Double type 
\end_layout

\begin_layout LyX-Code
Double
\end_layout

\begin_layout Section
Predicates
\end_layout

\begin_layout Standard
Having defined our types, we are ready to set up predicates.
 In our example introduced above we could define a predicate 
\emph on
label 
\emph default
that maps constiuents to labels using 
\end_layout

\begin_layout LyX-Code
predicate label: Int x Label;
\end_layout

\begin_layout Standard
Note that we use integers to represent the constiuents.
 As the integer type contains a vast amount of constants grouding of such
 a predicate can become prohibitive.
 One could overcome this with two possible ways: have a special type with
 one constant for each constituent or have an additional predicate that
 denotes integers which are representing constituents.
 The first way is a bit troublesome because it requires to have a different
 type for each problem instance and types.
 However, we see types as a rather static concept, dynamic information is
 exclusively handled by predicates and their atoms.
 Thus we go for the latter option and define another predicate 
\emph on
candidate
\emph default
: 
\end_layout

\begin_layout LyX-Code
predicate candidate: Int;
\end_layout

\begin_layout Standard
We differentiate between three types of predicates: hidden, observed and
 global ones.
\end_layout

\begin_layout Subsection
Hidden Predicates
\end_layout

\begin_layout Subsection
Observed Predicates
\end_layout

\begin_layout Subsection
Global Predicates
\end_layout

\begin_layout Section
Weight Functions
\end_layout

\begin_layout Standard
The final part of a signature consists of its 
\emph on
weight functions
\emph default
.
 They will be used to map (ground) formulas to weights that penalize or
 reward violations of these formulas.
 For example, it will be useful to reward or penalize the existance of particula
r labels in a solution.
 For this we could define a weight function
\end_layout

\begin_layout LyX-Code
weight w_label: Label -> Double;
\end_layout

\begin_layout Standard
This defines 
\emph on
w_label
\emph default
 to map labels to double values.
 Note that weight functions, just as predicates, have to start with lowercase
 letters and can contain underscores.
\end_layout

\begin_layout Standard
If we were are sure tha the existence of labels should only be rewarded
 we can write
\end_layout

\begin_layout LyX-Code
weight w_label: Label -> Double+;
\end_layout

\begin_layout Standard
This ensures that the weight function maps labels to non-negative real values.
 Correspondingly, 
\end_layout

\begin_layout LyX-Code
weight w_label: Label -> Double-;
\end_layout

\begin_layout Standard
makes sure that the existence of labels are always penalized.
 Constraining the sign of a weight function will be very important for efficient
 inference.
\end_layout

\begin_layout Chapter
Models
\end_layout

\begin_layout Standard
Once we have defined the symbols of our language we are ready to use these
 to make statements about the domain.
 We call these statements 
\emph on
factor formulas
\emph default
.
 A collection of such statements is called a 
\emph on
model
\emph default
.
 Before we can describe these statements we need to introduce their main
 building blocks: terms and boolean formulas.
 
\end_layout

\begin_layout Section
Terms
\end_layout

\begin_layout Standard
The most atomic building blocks of models are 
\emph on
terms
\emph default
.
 A term is a symbol that describes an entity of the domain.
 Terms always have a type associated with them.
\end_layout

\begin_layout Subsection
Constants
\end_layout

\begin_layout Standard
All constants are terms.
 For example, A0, A1 and 
\begin_inset Quotes eld
\end_inset

AM-MOD
\begin_inset Quotes erd
\end_inset

 are all terms.
\end_layout

\begin_layout Subsection
Variables
\end_layout

\begin_layout Standard
Variables serve as placeholders for other terms.
 Their type constraints the type of terms they can be replaced with.
 Variables are words that begin a lowercase letter and may contain underscores.
 
\end_layout

\begin_layout Subsection
Function Applications
\end_layout

\begin_layout Standard
Function applications are terms that apply a function to some argument terms.
 The type of a function application is the return type of the function.
 Thebeast comes with a set of build-in functions, such as +,-,/,* etc that
 can be used with infix notation.
 For now no own functions can be defined.
 Later versions will lift this restriction.
 
\end_layout

\begin_layout Subsection
Weight Terms
\end_layout

\begin_layout Standard
Finally, weight terms are weight functions applied to terms typed according
 to the signature of the function.
 
\end_layout

\begin_layout Section
Boolean Formulas
\end_layout

\begin_layout Standard
Terms can be assembled into boolean formulas using atoms, logical connectives
 and quantifiers.
 We can write 
\end_layout

\begin_layout LyX-Code
candidate(c)
\end_layout

\begin_layout LyX-Code
candidate(c) => label(c,A0)
\end_layout

\begin_layout LyX-Code
candidate(c) & label(c,A0)
\end_layout

\begin_layout LyX-Code
candidate(c) | label(c,A0)
\end_layout

\begin_layout LyX-Code
forall Label l: exist Int c: candidate(c) => label(c,l)
\end_layout

\begin_layout Standard
Thebeast also allows us to use cardinal constraints such as 
\end_layout

\begin_layout LyX-Code
forall Int c: candidate(c) => |Label l: label(c,l)| <= 1
\end_layout

\begin_layout Standard
indicating that for each candidate node there are no more than 1 label.
 Say we also have a hidden predicate 
\emph on
hasLabel
\emph default
 that indicates whether a node should have a label we can write 
\end_layout

\begin_layout LyX-Code
forall Int c: hasLabel(c) => |Label l: label(c,l)| >= 1
\end_layout

\begin_layout Standard
As of now equality constraints are not allowed but can be easily encoded
 via a 
\begin_inset Formula $\leq$
\end_inset

 and a 
\begin_inset Formula $\geq$
\end_inset

 constraint.
 
\end_layout

\begin_layout Section
Factor Formulas
\end_layout

\begin_layout Standard
A model is essentially a collection of factor formulas.
 Each factor formula describes a set of similar factors in the probabilistic
 model.
 It can be seen as a 
\emph on
parametrized
\emph default
 factor.
 A factor formula has the following form
\begin_inset Foot
status collapsed

\begin_layout Standard
Lines can be arbitarily broken
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
factor: for <QUANTIFICATION> 
\end_layout

\begin_layout LyX-Code
if <CONDITION> add [<FORMULA>] * <WEIGHT>;
\end_layout

\begin_layout Standard
where QUANTIFICATION is a list of variables with types, CONDITION a boolean
 formula that only contains observed predicates, FORMULA a boolean formula
 that contains at least one hidden predicate and WEIGHT a term to type 
\emph on
Double
\emph default
.
 CONDITION, FORMULA and WEIGHT may not contain variables not quantified
 in QUANTIFICATION.
 
\end_layout

\begin_layout Standard
For example
\end_layout

\begin_layout LyX-Code
factor: for Int c, Label l 
\end_layout

\begin_layout LyX-Code
if candidate(c) add [label(c,l)] * w_label(l);
\end_layout

\begin_layout Standard
This reads as follows: for each label l and integer c where c must be a
 candidate we add the value 
\emph on
w_label(l)
\emph default
 to the total score if 
\emph on
c
\emph default
 is labelled with 
\emph on
l
\emph default
.
 
\end_layout

\begin_layout Standard
More general, for each variable assignment for the given quantification
 that satisfies both the 
\emph on
condition
\emph default
 and the 
\emph on
formula 
\emph default
we add to the total score a weight which is a function of the variables.
 
\end_layout

\begin_layout Standard
Note that one could potentially write
\end_layout

\begin_layout LyX-Code
factor: for <QUANTIFICATION> 
\end_layout

\begin_layout LyX-Code
add [<CONDITION> & <FORMULA>] * <WEIGHT>;
\end_layout

\begin_layout Standard
to get the same semantics.
 However the main complexity of a model comes from how hidden predicates
 are involved; splitting hidden and observed part of a formula as we did
 in the example helps thebeast to optimize inference.
 In future versions this splitting might be done automatically.
\end_layout

\begin_layout Standard
We can also name a factor formula
\end_layout

\begin_layout LyX-Code
factor <NAME>: for <QUANTIFICATION> 
\end_layout

\begin_layout LyX-Code
if <CONDITION> add [<FORMULA>] * <WEIGHT>;
\end_layout

\begin_layout Standard
where NAME is a lowercase string.
 This helps while debugging or when some components (learner, solver, feature
 collector) should behave differently for different formulas.
 
\end_layout

\begin_layout Chapter
\begin_inset LatexCommand label
name "cha:Corpora"

\end_inset

Corpora
\end_layout

\begin_layout Chapter
Learning Weights
\end_layout

\begin_layout Section
Instantiating Weights
\end_layout

\begin_layout Section
Estimating Weights
\end_layout

\begin_layout Chapter
Inference
\end_layout

\begin_layout Section
Cutting Plane Solver
\end_layout

\begin_layout Section
Propositional Models
\end_layout

\end_body
\end_document
