#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{aaai}
\newcommand{\lang}{\textsc{DFacto}}
\end_preamble
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Declarative Probabilistic Programming for Undirected Graphical Models: Open
 Up to Scale Up
\end_layout

\begin_layout Abstract
While many probabilistic programming language focus on restricting expressivenes
s to achieve complexity guarantees, we argue that we should rather design
 
\emph on
open
\emph default
 languages that are designed to grow over time.
 In the languages we envision, new types of constructs, such as cardinality
 constraints, projectivity assumptions, acyclicity, are constantly added
 to a ever increasing set of declarative building blocks.
 This leads to 
\emph on
more concise
\emph default
 programs.
 More importantly, we argue and show that it can also lead to
\emph on
 more efficient
\emph default
 inference if we use 
\emph on
compositional
\emph default
 inference methods that can exploit building-block specific sub-routines.
 To this end we present 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

, a open-ended language to describe complex probabilistic models.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In recent years Probabilistic Programming languages have been adopted in
 several fields, and used for applications such as Natural Language Processing,
 Planning, Sensor Networks, to name only a few.
 One of most successful approaches is Markov Logic, a language that uses
 weighted first order logic to describe Markov Networks of repetitive structure.
 It is one of the most expressive languages as it can describe arbitrary
 Markov Networks.
 Its expressiveness comes at a price: we loose any complexity guaranteees
 that less expressive langauges tend to give.
 If the user designs the 
\begin_inset Quotes eld
\end_inset

wrong
\begin_inset Quotes erd
\end_inset

 model, inference and learning will be painfully slow.
 While often there can be an efficient 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 model for the same task, there are cleary times when this is not the case.
 One example is dependency parsing, where we are required to model relation
 structure that represents projective trees.
 Formulating this in Markov Logic leads to graphical models with very high
 treewidth, and hence high complexity.
\end_layout

\begin_layout Standard
In this work we argue that Markov Logic, in order to scale up, needs to
 
\emph on
open up
\emph default
.
 That is, we propose to generalize Markov Logic to not provide a fixed and
 small set of logical connectives and universal or existential quantification.
 Instead, it should allow users to add their own constructs, such as existing
 Markov Logic building blocks, but also cardinality, projectivity or acyclicity
 constraints.
 The main function of the language is then to provide the glue to assemble
 these constructs.
 At first sight, new building blocks may only be syntactic sugar.
 Markov Logic can, albeit less concise, already express such constraints.
 However, for inference routines that decompose according to the structure
 of our model, the subroutines for these building blocks can often be implemente
d efficiently.
 For example, Belief Propagation essentially requires each factor to marginalize
 itself.
 For a spanning tree constraint this can be achieved in cubic time.
 
\end_layout

\begin_layout Standard
In the following we will present 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout
Declarative Factor Graphs, Open.
\end_layout

\end_inset

 an attempt to provide the glue for open-ended probabilistic programming.
 We have used it to (a) implement Markov Logic, and (b) extend it with powerful
 building blocks such as a projective spanning tree constraint.
 We show empirically that this allows us to implement a dramatically more
 efficient dependency parser than in pure Markov Logic.
\end_layout

\begin_layout Standard
Note as running example we use dependency parsing.
 Here we need to find the syntactic relations between the tokens of a sentence.
 For example, in 
\begin_inset Quotes eld
\end_inset

the man walks
\begin_inset Quotes erd
\end_inset

 man is the subject of walks, and 
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

 is the determiner of 
\begin_inset Quotes eld
\end_inset

man.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Domains, Variables, Worlds
\end_layout

\begin_layout Standard
The glue that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 provides are abstract datatypes/interfaces for building blocks, as well
 as a set of initial constructs.
 We will describe them using classes and traits of Scala, a functional object-or
iented programming language.
 
\end_layout

\begin_layout Standard
A 
\family typewriter
Domain[T]
\family default
 contains (Scala) objects of type 
\family typewriter
T
\family default
 we want to talk about; implementations of Domain usually need to provide
 an iterator over their objects, as well as a 
\family typewriter
contains
\family default
 method to indicate Domain membership.
 Note that a Domain can be infinite, and also be used when no enumeration
 of its objects is possible.
 
\end_layout

\begin_layout Standard
The three core types of domains are 
\family typewriter
Values, Tuples, 
\family default
and 
\family typewriter
Functions
\family default
.
 The former simply represents a user-defined set of objects of type T; the
 latter a the set of all functions from a domain to a target.
 
\end_layout

\begin_layout LyX-Code
val Tokens = Values(0,1,2,3,4,5,...)
\end_layout

\begin_layout LyX-Code
val Parses = (Tokens x Tokens) -> Bools 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Ultimately we want to reason about the objects of our domains, using generic
 knowledge independent of their actual identity.
 To do so we need placeholders that allow us to speak about objects in an
 abstract fashion.
 This is generally achieved by variables.
\end_layout

\end_inset

In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 a variable is represented by objects of the trait 
\family typewriter
Var[T]
\family default
.
 Each variable has a name and a domain that specifies which values the variable
 can possibly take on.
 Variables can be simple (referring to simple objects) or complex (refering
 to functions) :
\end_layout

\begin_layout LyX-Code
val root = Var(
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

, Tokens)
\end_layout

\begin_layout LyX-Code
val parse = Var(
\begin_inset Quotes eld
\end_inset

parse
\begin_inset Quotes erd
\end_inset

, Parses)
\end_layout

\begin_layout Plain Layout
One can understand each variable as a question about the world we seek to
 model.
 In this sense each assignment to our variables refers to a possible state
 of the world.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 we hence refer to assignments using the 
\family typewriter
World
\family default
 trait.
 The core method a 
\family typewriter
World
\family default
 provides is 
\family typewriter
resolveVar
\family default
: it returns the object the variable is assigned to.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
or 
\family typewriter
None
\family default
 if no such object exists (for partial worlds)
\end_layout

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To construct worlds we can use 
\family typewriter
MutableWorld
\family default
 objects:
\end_layout

\begin_layout LyX-Code
val world = new MutableWorld
\end_layout

\begin_layout LyX-Code
world(root) = 0
\end_layout

\begin_layout LyX-Code
world(parse) = Map((0,2)->true,(0,4)->true)
\end_layout

\begin_layout LyX-Code
world.close(parse)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Terms
\end_layout

\begin_layout Standard
Intuitively, a term is a symbolic expression that is, given a possible world,
 evaluated to an object.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 a term is an instance of a 
\family typewriter
Term
\family default
 trait that has to implement an 
\family typewriter
evaluate(world)
\family default
 method.
 It defines how the term maps worlds to values.
 A simple example of a term is the following:
\end_layout

\begin_layout LyX-Code
Exp(Indicator(FunApp(edge,Tuple(root,5)))
\end_layout

\begin_layout Standard
It is actually a composed term with an 
\family typewriter
Indicator
\family default
 term on its top-level.
 An indicator (or iverson bracket) evaluates to 1 if the boolean term inside
 evaluates to 
\family typewriter
TRUE
\family default
, and 0 otherwise.
 The 
\family typewriter
FunApp
\family default
 term applies the result of evaluating the first argument to the result
 of evaluating the second.
 The edge term is the 
\family typewriter
Var
\family default
 object we defined earlier.
 It evaluates to the function the variable is bound to in the given world.
 The other terms are defined accordingly.
 
\end_layout

\begin_layout Standard
Scala allows us to use a lot syntactic sugar to make code more concise.
 In our case we can use this to alternatively write
\end_layout

\begin_layout LyX-Code
exp(${edge(root,5)})
\end_layout

\begin_layout Standard
The terms so far provide no means of abstraction.
 To change this, we simply add 
\family typewriter
Quantification
\family default
 terms which evaluate subterms for all objects of a given domain.
 A simple case is
\end_layout

\begin_layout LyX-Code
sum(Tokens){i=> ${tag(i,VB)->edge(root,i)}}
\end_layout

\begin_layout Standard
This term is evaluated as follows: we replace i in the inner term with each
 possible value in Tokens, then we evaluate the inner term, get a real value,
 and sum up these values.
 It should be clear that by placing this term into the exponential function
 we already have an (unnormalized) MLN.
 
\end_layout

\begin_layout Standard
Terms are the main building blocks of probabilistic models.
 For most users, working with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 means composing terms into more complex terms, and use them to describe
 probabilistic models.
 Just as traditional logics allow them to compose terms into boolean formulae
 that describe the world.
 Some users, however, will design and implement new terms.
 In our running example, one could add a projective spanning tree constraint
 
\family typewriter
PTree
\family default
:
\end_layout

\begin_layout LyX-Code
exp(${edge(root,5)})*PTree(edge,root)
\end_layout

\begin_layout Standard

\family typewriter
PTree(edge)
\family default
 returns 1 if the function in 
\family typewriter
edge
\family default
 corresponds to a spanning tree over objects in 
\family typewriter
Tokens
\family default
 rooted at 
\family typewriter
root
\family default
, and 0 otherwise.
 Hence the above term will return 1 iff 
\family typewriter
edge
\family default
 is a spanning tree and if the 
\family typewriter
root
\family default
 value is linked to token 5.
 
\end_layout

\begin_layout Section
Compositional Inference
\end_layout

\begin_layout Standard
We could also write some logical formulae to express the projective spanning
 tree constraint above.
 However, introducing an own term for this makes our model more concise.
 More importantly though, it can also make inference more tractable.
 
\end_layout

\begin_layout Standard
To illustrate this let us look at the case of Belief Propagation.
 Smith and Eisner have shown how efficient dynamic programming methods can
 be used to calculate the messages of a projective tree constraint factor.
 In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 we allow the inference engine to make use of this.
 When the language designer adds a new term, he can also override a 
\family typewriter
message
\family default
 method that calculates its outgoing messages during BP.
 
\end_layout

\begin_layout Standard
Note that this type of compositional inference is not exclusive to Sum Product
 BP, and the spanning tree factor.
 Similar approaches can be used for algorithms such as Max Product BP, or
 even Integer Linear Programming, and other type of graphical structures.
 Moreover, note that we can follow a similar approach for inference methods
 that do not unroll the full graph.
 For example, terms can have a 
\family typewriter
separate
\family default
 method for Cutting Plane Inference that returns all factors that are not
 
\emph on
maximally satisfied
\emph default
 in a given world.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 is closely related to Markov Logic: it is declarative, and focuses on loglinear
 models.
 However, it is not limited to the logical connectives and quantifications
 present in ML; rather, it serves as a framework for extensions such as
 cardinality constraints, or the tree constraint presented here.
 
\end_layout

\begin_layout Standard
The possibility of incorporating tailor-made inference is also present in
 FACTORIE; But while FACTORIE focuses on imperative constructs, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lang{}
\end_layout

\end_inset

 is primarily declarative and requires imperative coding only for a few
 extension designers.
 In this sense it is actually close languages like Figaro or Blog, which
 allow inclusion of tailor-made proposal functions.
 However, these languages are a) primarily generative, and b) limit themselves
 to MCMC.
 
\end_layout

\begin_layout Section
Results and Conclusion
\end_layout

\begin_layout Standard
To show the dramatic impact that these tailor-made terms can yield, we compared
 a model with PTree constraint to a model that uses FOL formulae to achieve
 the same.
 For sentences longer than 10, our speed-ups were dramatic: ....
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/Users/riedelcastro/projects/papers.fresh/bibtex/riedel"
options "plain"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
